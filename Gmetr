/*
 * Live G-meter - OPTIMALIZOVANÝ
 * Autor: kabelkao
 * Komunikace: ČESKY
 * 
 * OPTIMALIZACE:
 * - Komprimovaná lookup table (úspora 67% RAM)
 * - Rychlejší vykreslování (jen dotčené oblasti)
 * - Vyčištěné konstanty a funkce
 */

#include <Arduino_GFX_Library.h>
#include <Adafruit_GFX.h>
#include <gfxfont.h>
#include <Fonts/FreeSansBold24pt7b.h>
#include <Fonts/FreeSans12pt7b.h>
#include <Wire.h>

// ═══════════════════════════════════════════════════════════
// NASTAVENÍ HARDWARU
// ═══════════════════════════════════════════════════════════

#define TFT_SCK   6
#define TFT_MOSI  7
#define TFT_CS    10
#define TFT_DC    2
#define TFT_RST   3
#define I2C_SDA   8
#define I2C_SCL   9

#define MPU6050_ADDR 0x68
#define MPU6050_PWR_MGMT_1   0x6B
#define MPU6050_ACCEL_XOUT_H 0x3B

// ═══════════════════════════════════════════════════════════
// KONSTANTY DISPLEJE
// ═══════════════════════════════════════════════════════════

#define DISPLAY_WIDTH  240
#define DISPLAY_HEIGHT 240
#define CENTER_X 120
#define CENTER_Y 120
#define TEXT_RADIUS 42

#define RING1_RADIUS 68
#define RING2_RADIUS 93
#define RING3_RADIUS 118
#define RING_THICKNESS 2
#define RING_PROTECTION 2

// BARVY
#define GRAY_CIRCLE 0x7BEF
#define LIGHT_GRAY 0xBDF7

// Poloměry vrstev
#define LAYER1_MIN TEXT_RADIUS
#define LAYER1_MAX (RING1_RADIUS - RING_PROTECTION)
#define LAYER2_MIN (RING1_RADIUS + RING_PROTECTION)
#define LAYER2_MAX (RING2_RADIUS - RING_PROTECTION)
#define LAYER3_MIN (RING2_RADIUS + RING_PROTECTION)
#define LAYER3_MAX (RING3_RADIUS - RING_PROTECTION)

// MEZERY
#define SEGMENT_GAP_WIDTH 3
#define RING_GAP_WIDTH 3
#define BORDER_THRESHOLD 35.0f

// ═══════════════════════════════════════════════════════════
// KONSTANTY SENZORU
// ═══════════════════════════════════════════════════════════

#define SMOOTH_SAMPLES 5
#define SMOOTHING_ALPHA 0.95f
#define MIN_G_THRESHOLD 0.05f
#define G_DISPLAY_PRECISION 0.05f
#define CALIBRATION_SAMPLES 100
#define ACCEL_SCALE 16384.0f

// ═══════════════════════════════════════════════════════════
// LADÍCÍ PŘEPÍNAČE
// ═══════════════════════════════════════════════════════════

#define DEBUG_DOT false

// ═══════════════════════════════════════════════════════════
// KOMPRIMOVANÁ LOOKUP TABLE
// ═══════════════════════════════════════════════════════════

struct PixelInfo {
  uint8_t sector : 3;  // 0-7
  uint8_t layer  : 2;  // 0-3
  bool isRing    : 1;  // 0-1
  uint8_t unused : 2;  // rezerva
};

PixelInfo pixelData[DISPLAY_HEIGHT][DISPLAY_WIDTH];

// ═══════════════════════════════════════════════════════════
// GLOBÁLNÍ PROMĚNNÉ
// ═══════════════════════════════════════════════════════════

Arduino_DataBus *bus = new Arduino_ESP32SPI(TFT_DC, TFT_CS, TFT_SCK, TFT_MOSI, -1);
Arduino_GFX *gfx = new Arduino_GC9A01(bus, TFT_RST, 2, true);

int16_t accelX, accelY, accelZ;
int16_t accelOffsetX = 0, accelOffsetY = 0, accelOffsetZ = 0;

float smoothX[SMOOTH_SAMPLES] = {0};
float smoothY[SMOOTH_SAMPLES] = {0};
int smoothIndex = 0;

float gravityX = 0, gravityY = 0;

int lastSector = -1;
int lastFillLevel = 0;
int lastSector2 = -1;
int lastFillLevel2 = 0;
float lastDisplayedG = -1.0f;

// ═══════════════════════════════════════════════════════════
// POMOCNÉ FUNKCE
// ═══════════════════════════════════════════════════════════

inline bool isValidPixel(int x, int y) {
  return (x >= 0 && x < DISPLAY_WIDTH && y >= 0 && y < DISPLAY_HEIGHT);
}

inline uint16_t getLayerColor(uint8_t layer) {
  switch(layer) {
    case 1: return BLUE;
    case 2: return WHITE;
    case 3: return RED;
    default: return BLACK;
  }
}

inline float normalizeAngle(float angle) {
  return (angle < 0) ? angle + 360.0f : angle;
}

// ═══════════════════════════════════════════════════════════
// LOGO
// ═══════════════════════════════════════════════════════════

void drawLogo() {
  gfx->fillScreen(BLACK);
  
  gfx->setFont(&FreeSansBold24pt7b);
  gfx->setTextColor(BLUE);
  
  const char* title = "G-metr";
  int16_t x1, y1;
  uint16_t w, h;
  gfx->getTextBounds(title, 0, 0, &x1, &y1, &w, &h);
  
  gfx->setCursor(CENTER_X - w / 2, CENTER_Y - 20);
  gfx->print(title);
  
  gfx->setFont(&FreeSans12pt7b);
  gfx->setTextColor(LIGHT_GRAY);
  
  const char* author = "by kabelkao";
  gfx->getTextBounds(author, 0, 0, &x1, &y1, &w, &h);
  
  gfx->setCursor(CENTER_X - w / 2, CENTER_Y + 30);
  gfx->print(author);
  
  gfx->setFont();
  gfx->setTextColor(WHITE);
  gfx->setTextSize(1);
  
  const char* loading = "Nacitam...";
  int loadW = strlen(loading) * 6;
  gfx->setCursor(CENTER_X - loadW / 2, CENTER_Y + 60);
  gfx->print(loading);
}

// ═══════════════════════════════════════════════════════════
// MPU6050
// ═══════════════════════════════════════════════════════════

void readMPU6050() {
  Wire.beginTransmission(MPU6050_ADDR);
  Wire.write(MPU6050_ACCEL_XOUT_H);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU6050_ADDR, 6, true);
  
  accelX = (Wire.read() << 8) | Wire.read();
  accelY = (Wire.read() << 8) | Wire.read();
  accelZ = (Wire.read() << 8) | Wire.read();
}

void calibrate() {
  long sumX = 0, sumY = 0, sumZ = 0;
  
  for (int i = 0; i < CALIBRATION_SAMPLES; i++) {
    readMPU6050();
    sumX += accelX;
    sumY += accelY;
    sumZ += accelZ;
    delay(10);
  }
  
  accelOffsetX = sumX / CALIBRATION_SAMPLES;
  accelOffsetY = sumY / CALIBRATION_SAMPLES;
  accelOffsetZ = (sumZ / CALIBRATION_SAMPLES) - (int16_t)ACCEL_SCALE;
}

// ═══════════════════════════════════════════════════════════
// LOOKUP TABLE
// ═══════════════════════════════════════════════════════════

void buildLookupTables() {
  // Inicializace
  for (int y = 0; y < DISPLAY_HEIGHT; y++) {
    for (int x = 0; x < DISPLAY_WIDTH; x++) {
      pixelData[y][x].sector = 7;  // neplatná hodnota
      pixelData[y][x].layer = 0;
      pixelData[y][x].isRing = false;
    }
  }
  
  // Vypočítej jen relevantní oblast
  int minCoord = CENTER_X - LAYER3_MAX - 5;
  int maxCoord = CENTER_X + LAYER3_MAX + 5;
  
  for (int y = minCoord; y <= maxCoord; y++) {
    if (y < 0 || y >= DISPLAY_HEIGHT) continue;
    
    for (int x = minCoord; x <= maxCoord; x++) {
      if (x < 0 || x >= DISPLAY_WIDTH) continue;
      
      int dx = x - CENTER_X;
      int dy = y - CENTER_Y;
      float distance = sqrt(dx*dx + dy*dy);
      
      float angle = normalizeAngle(atan2(-dy, -dx) * 180.0f / PI);
      
      // Kruhy s mezerami
      auto checkRingWithGap = [&](float ringRadius) -> bool {
        if (distance < ringRadius - RING_THICKNESS || distance > ringRadius) {
          return false;
        }
        
        for (int s = 0; s < 8; s++) {
          float borderAngle = normalizeAngle((s * 45.0f) + 22.5f);
          float borderRad = borderAngle * PI / 180.0f;
          float pixelRad = angle * PI / 180.0f;
          float perpDistance = abs(distance * sin(pixelRad - borderRad));
          
          if (perpDistance < RING_GAP_WIDTH / 2.0f) {
            return false;
          }
        }
        return true;
      };
      
      if (checkRingWithGap(RING1_RADIUS) || 
          checkRingWithGap(RING2_RADIUS) || 
          checkRingWithGap(RING3_RADIUS)) {
        pixelData[y][x].isRing = true;
      }
      
      // Segmenty
      if (distance < TEXT_RADIUS || distance > LAYER3_MAX) continue;
      
      uint8_t layer = 0;
      if (distance >= LAYER1_MIN && distance <= LAYER1_MAX) layer = 1;
      else if (distance >= LAYER2_MIN && distance <= LAYER2_MAX) layer = 2;
      else if (distance >= LAYER3_MIN && distance <= LAYER3_MAX) layer = 3;
      
      if (layer == 0) continue;
      
      uint8_t sector = (int)((angle + 22.5f) / 45.0f) % 8;
      
      // Kontrola mezer
      bool inGap = false;
      for (int s = 0; s < 8; s++) {
        float borderAngle = normalizeAngle((s * 45.0f) + 22.5f);
        float borderRad = borderAngle * PI / 180.0f;
        float pixelRad = angle * PI / 180.0f;
        float perpDistance = abs(distance * sin(pixelRad - borderRad));
        
        if (perpDistance < SEGMENT_GAP_WIDTH / 2.0f) {
          inGap = true;
          break;
        }
      }
      
      if (!inGap) {
        pixelData[y][x].sector = sector;
        pixelData[y][x].layer = layer;
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════
// VYKRESLOVÁNÍ (OPTIMALIZOVANÉ)
// ═══════════════════════════════════════════════════════════

void drawSectorFast(int sector, int fillLevel) {
  int minCoord = CENTER_X - LAYER3_MAX;
  int maxCoord = CENTER_X + LAYER3_MAX;
  
  for (int y = minCoord; y <= maxCoord; y++) {
    if (!isValidPixel(0, y)) continue;
    
    for (int x = minCoord; x <= maxCoord; x++) {
      if (!isValidPixel(x, y)) continue;
      
      if (pixelData[y][x].sector == sector && 
          pixelData[y][x].layer > 0 && 
          pixelData[y][x].layer <= fillLevel) {
        gfx->drawPixel(x, y, getLayerColor(pixelData[y][x].layer));
      }
    }
  }
}

void clearSectorFast(int sector, int fillLevel) {
  int minCoord = CENTER_X - LAYER3_MAX;
  int maxCoord = CENTER_X + LAYER3_MAX;
  
  for (int y = minCoord; y <= maxCoord; y++) {
    if (!isValidPixel(0, y)) continue;
    
    for (int x = minCoord; x <= maxCoord; x++) {
      if (!isValidPixel(x, y)) continue;
      
      if (pixelData[y][x].sector == sector && 
          pixelData[y][x].layer > 0 && 
          pixelData[y][x].layer <= fillLevel) {
        gfx->drawPixel(x, y, BLACK);
      }
    }
  }
}

void redrawRingsOverSectors() {
  int minCoord = CENTER_X - LAYER3_MAX;
  int maxCoord = CENTER_X + LAYER3_MAX;
  
  for (int y = minCoord; y <= maxCoord; y++) {
    if (!isValidPixel(0, y)) continue;
    
    for (int x = minCoord; x <= maxCoord; x++) {
      if (!isValidPixel(x, y)) continue;
      
      if (pixelData[y][x].isRing) {
        gfx->drawPixel(x, y, LIGHT_GRAY);
      }
    }
  }
}

void drawStaticElements() {
  gfx->drawCircle(CENTER_X, CENTER_Y, TEXT_RADIUS, GRAY_CIRCLE);
  gfx->drawCircle(CENTER_X, CENTER_Y, TEXT_RADIUS - 1, GRAY_CIRCLE);
  redrawRingsOverSectors();
}

void drawGValue(float g) {
  gfx->fillCircle(CENTER_X, CENTER_Y, TEXT_RADIUS - 2, BLACK);
  
  int gTimes10 = (int)(g * 10.0f);
  String text = String(gTimes10);
  
  gfx->setFont(&FreeSansBold24pt7b);
  gfx->setTextColor(WHITE);
  
  int16_t x1, y1;
  uint16_t w, h;
  gfx->getTextBounds(text, 0, 0, &x1, &y1, &w, &h);
  
  gfx->setCursor(CENTER_X - w / 2, CENTER_Y + h / 2 - 8);
  gfx->print(text);
  
  gfx->setFont();
  gfx->setTextColor(GRAY_CIRCLE);
  gfx->setTextSize(1);
  
  const char* label = "x10";
  int labelW = strlen(label) * 6;
  gfx->setCursor(CENTER_X - labelW / 2, CENTER_Y + 20);
  gfx->print(label);
}

void drawDebugDot(float angle, float g) {
  float radius = constrain(g * 50, 0, 115);
  int x = CENTER_X - cos(angle) * radius;
  int y = CENTER_Y - sin(angle) * radius;
  
  gfx->fillCircle(x, y, 5, BLUE);
  gfx->drawCircle(x, y, 5, CYAN);
}

// ═══════════════════════════════════════════════════════════
// SETUP
// ═══════════════════════════════════════════════════════════

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n═══════════════════════════════════");
  Serial.println("  G-metr - OPTIMALIZOVANÝ");
  Serial.println("  Autor: kabelkao");
  Serial.println("  RAM úspora: 67%");
  Serial.println("═══════════════════════════════════\n");
  
  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);
  
  Wire.beginTransmission(MPU6050_ADDR);
  Wire.write(MPU6050_PWR_MGMT_1);
  Wire.write(0x00);
  byte error = Wire.endTransmission();
  
  if (error == 0) {
    Serial.println("✓ MPU6050 připojen");
  } else {
    Serial.println("✗ Chyba: MPU6050 nenalezen!");
    while(1) delay(100);
  }
  
  Serial.println("Kalibrace MPU6050...");
  calibrate();
  Serial.println("✓ Kalibrace dokončena");
  
  Serial.println("Inicializuji displej...");
  gfx->begin(40000000);
  
  drawLogo();
  
  Serial.println("Předpočítávám lookup tables...");
  unsigned long startTime = millis();
  buildLookupTables();
  unsigned long elapsed = millis() - startTime;
  Serial.print("✓ Hotovo za ");
  Serial.print(elapsed);
  Serial.println(" ms");
  
  gfx->fillScreen(BLACK);
  
  Serial.println("Kreslím statické prvky...");
  drawStaticElements();
  
  Serial.println("\n✓ G-metr spuštěn!\n");
}

// ═══════════════════════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════════════════════

void loop() {
  readMPU6050();
  
  accelX -= accelOffsetX;
  accelY -= accelOffsetY;
  
  float accelX_g = accelX / ACCEL_SCALE;
  float accelY_g = accelY / ACCEL_SCALE;
  
  smoothX[smoothIndex] = accelX_g;
  smoothY[smoothIndex] = accelY_g;
  smoothIndex = (smoothIndex + 1) % SMOOTH_SAMPLES;
  
  float avgX = 0, avgY = 0;
  for (int i = 0; i < SMOOTH_SAMPLES; i++) {
    avgX += smoothX[i];
    avgY += smoothY[i];
  }
  avgX /= SMOOTH_SAMPLES;
  avgY /= SMOOTH_SAMPLES;
  
  gravityX = SMOOTHING_ALPHA * gravityX + (1 - SMOOTHING_ALPHA) * avgX;
  gravityY = SMOOTHING_ALPHA * gravityY + (1 - SMOOTHING_ALPHA) * avgY;
  
  float dynX = avgX - gravityX;
  float dynY = avgY - gravityY;
  
  float totalG = sqrt(dynX * dynX + dynY * dynY);
  float angle = atan2(dynX, dynY);
  
  float angleDeg = normalizeAngle(angle * 180.0f / PI);
  int sector = (int)((angleDeg + 22.5f) / 45.0f) % 8;
  
  int fillLevel;
  if (totalG < MIN_G_THRESHOLD) fillLevel = 0;
  else if (totalG < 0.5f) fillLevel = 1;
  else if (totalG < 1.0f) fillLevel = 2;
  else fillLevel = 3;
  
  float sectorCenter = sector * 45.0f;
  float distanceFromCenter = abs(angleDeg - sectorCenter);
  bool nearBorder = (distanceFromCenter > BORDER_THRESHOLD);
  
  int sector2 = -1;
  int fillLevel2 = 0;
  
  if (nearBorder && fillLevel > 0) {
    sector2 = (angleDeg < sectorCenter) ? (sector - 1 + 8) % 8 : (sector + 1) % 8;
    fillLevel2 = fillLevel - 1;
    if (fillLevel2 <= 0) {
      sector2 = -1;
      fillLevel2 = 0;
    }
  }
  
  bool sectorChanged = (sector != lastSector || 
                        fillLevel != lastFillLevel ||
                        sector2 != lastSector2 ||
                        fillLevel2 != lastFillLevel2);
  
  if (sectorChanged) {
    if (lastSector >= 0 && lastFillLevel > 0) {
      clearSectorFast(lastSector, lastFillLevel);
    }
    if (lastSector2 >= 0 && lastFillLevel2 > 0) {
      clearSectorFast(lastSector2, lastFillLevel2);
    }
    
    if (fillLevel > 0) {
      drawSectorFast(sector, fillLevel);
    }
    if (sector2 >= 0 && fillLevel2 > 0) {
      drawSectorFast(sector2, fillLevel2);
    }
    
    redrawRingsOverSectors();
    
    lastSector = sector;
    lastFillLevel = fillLevel;
    lastSector2 = sector2;
    lastFillLevel2 = fillLevel2;
  }
  
  if (abs(totalG - lastDisplayedG) > G_DISPLAY_PRECISION || lastDisplayedG < 0) {
    drawGValue(totalG);
    lastDisplayedG = totalG;
  }
  
  if (DEBUG_DOT && totalG > MIN_G_THRESHOLD) {
    drawDebugDot(angle, totalG);
  }
  
  delay(20);
}
