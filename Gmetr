/*
 * Live G-meter - S LOGEM
 * Autor: kabelkao
 * Komunikace: ČESKY
 * 
 * ZMĚNY:
 * - Logo při startu (během načítání lookup tables)
 * - TEST_MODE vypnutý (live data)
 * - Česká komunikace
 */

#include <Arduino_GFX_Library.h>
#include <Adafruit_GFX.h>
#include <gfxfont.h>
#include <Fonts/FreeSansBold24pt7b.h>
#include <Fonts/FreeSans12pt7b.h>
#include <Wire.h>

// ═══════════════════════════════════════════════════════════
// NASTAVENÍ
// ═══════════════════════════════════════════════════════════

#define TFT_SCK   6
#define TFT_MOSI  7
#define TFT_CS    10
#define TFT_DC    2
#define TFT_RST   3
#define I2C_SDA   8
#define I2C_SCL   9

#define MPU6050_ADDR 0x68
#define MPU6050_PWR_MGMT_1   0x6B
#define MPU6050_ACCEL_XOUT_H 0x3B

#define CENTER_X 120
#define CENTER_Y 120
#define TEXT_RADIUS 42

#define RING1_RADIUS 68
#define RING2_RADIUS 93
#define RING3_RADIUS 118
#define RING_THICKNESS 2
#define RING_PROTECTION 2

// BARVY
#define GRAY_CIRCLE 0x7BEF     // Šedá (ochranný kruh)
#define LIGHT_GRAY 0xBDF7      // Světle šedá (kruhy)
#define COLOR_BLUE   0x04FF    // Modrá
#define COLOR_WHITE  0xFFFF    // Bílá
#define COLOR_RED    0xF800    // Červená

// Poloměry vrstev
#define LAYER1_MIN TEXT_RADIUS
#define LAYER1_MAX (RING1_RADIUS - RING_PROTECTION)
#define LAYER2_MIN (RING1_RADIUS + RING_PROTECTION)
#define LAYER2_MAX (RING2_RADIUS - RING_PROTECTION)
#define LAYER3_MIN (RING2_RADIUS + RING_PROTECTION)
#define LAYER3_MAX (RING3_RADIUS - RING_PROTECTION)

#define BORDER_THRESHOLD 35.0

// ROVNÉ MEZERY (v pixelech)
#define SEGMENT_GAP_WIDTH 3
#define RING_GAP_WIDTH 3

// ═══════════════════════════════════════════════════════════
// LADÍCÍ PŘEPÍNAČE
// ═══════════════════════════════════════════════════════════

#define TEST_MODE false  // false = LIVE DATA (vypnuto testování)
#define DEBUG_DOT false  // true = modrá tečka

Arduino_DataBus *bus = new Arduino_ESP32SPI(TFT_DC, TFT_CS, TFT_SCK, TFT_MOSI, -1);
Arduino_GFX *gfx = new Arduino_GC9A01(bus, TFT_RST, 2, true);

// ═══════════════════════════════════════════════════════════
// LOOKUP TABLES
// ═══════════════════════════════════════════════════════════

uint8_t pixelSector[240][240];
uint8_t pixelLayer[240][240];
bool pixelIsRing[240][240];

// ═══════════════════════════════════════════════════════════
// MPU6050 PROMĚNNÉ
// ═══════════════════════════════════════════════════════════

int16_t accelX, accelY, accelZ;
int16_t accelOffsetX = 0, accelOffsetY = 0, accelOffsetZ = 0;

#define SMOOTH_SAMPLES 5
float smoothX[SMOOTH_SAMPLES] = {0};
float smoothY[SMOOTH_SAMPLES] = {0};
int smoothIndex = 0;

float gravityX = 0, gravityY = 0;
const float alpha = 0.95;

int lastSector = -1;
int lastFillLevel = 0;
int lastSector2 = -1;
int lastFillLevel2 = 0;
float lastDisplayedG = -1.0;

// ═══════════════════════════════════════════════════════════
// LOGO (zobrazí se při startu)
// ═══════════════════════════════════════════════════════════

void drawLogo() {
  gfx->fillScreen(BLACK);
  
  // "G-metr"
  gfx->setFont(&FreeSansBold24pt7b);
  gfx->setTextColor(COLOR_BLUE);
  
  const char* title = "G-metr";
  int16_t x1, y1;
  uint16_t w, h;
  gfx->getTextBounds(title, 0, 0, &x1, &y1, &w, &h);
  
  int titleX = CENTER_X - w / 2;
  int titleY = CENTER_Y - 20;
  gfx->setCursor(titleX, titleY);
  gfx->print(title);
  
  // "by kabelkao"
  gfx->setFont(&FreeSans12pt7b);
  gfx->setTextColor(LIGHT_GRAY);
  
  const char* author = "by kabelkao";
  gfx->getTextBounds(author, 0, 0, &x1, &y1, &w, &h);
  
  int authorX = CENTER_X - w / 2;
  int authorY = CENTER_Y + 30;
  gfx->setCursor(authorX, authorY);
  gfx->print(author);
  
  // "Načítám..."
  gfx->setFont();
  gfx->setTextColor(WHITE);
  gfx->setTextSize(1);
  
  const char* loading = "Nacitam...";
  int loadW = strlen(loading) * 6;
  int loadX = CENTER_X - loadW / 2;
  int loadY = CENTER_Y + 60;
  gfx->setCursor(loadX, loadY);
  gfx->print(loading);
}

// ═══════════════════════════════════════════════════════════
// SETUP
// ═══════════════════════════════════════════════════════════

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n═══════════════════════════════════");
  Serial.println("  G-metr - LIVE DATA");
  Serial.println("  Autor: kabelkao");
  Serial.println("  8 směrů × 3 intenzity = 24 polí");
  Serial.println("═══════════════════════════════════\n");
  
  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);
  
  Wire.beginTransmission(MPU6050_ADDR);
  Wire.write(MPU6050_PWR_MGMT_1);
  Wire.write(0x00);
  byte error = Wire.endTransmission();
  
  if (error == 0) {
    Serial.println("✓ MPU6050 připojen");
  } else {
    Serial.println("✗ Chyba: MPU6050 nenalezen!");
    while(1) delay(100);
  }
  
  Serial.println("Kalibrace MPU6050...");
  calibrate();
  Serial.println("✓ Kalibrace dokončena");
  
  Serial.println("Inicializuji displej...");
  gfx->begin(40000000);
  
  // ═══════════════════════════════════════════════════════
  // ZOBRAZ LOGO
  // ═══════════════════════════════════════════════════════
  
  drawLogo();
  
  // ═══════════════════════════════════════════════════════
  // PŘEDPOČÍTÁVÁNÍ (s logem na displeji)
  // ═══════════════════════════════════════════════════════
  
  Serial.println("Předpočítávám lookup tables...");
  unsigned long startTime = millis();
  buildLookupTables();
  unsigned long elapsed = millis() - startTime;
  Serial.print("✓ Hotovo za ");
  Serial.print(elapsed);
  Serial.println(" ms");
  
  // ═══════════════════════════════════════════════════════
  // VYMAŽ LOGO A NAKRESLI UI
  // ═══════════════════════════════════════════════════════
  
  gfx->fillScreen(BLACK);
  
  Serial.println("Kreslím statické prvky...");
  drawStaticElements();
  
  Serial.println("\n✓ G-metr spuštěn!\n");
}

// ═══════════════════════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════════════════════

void loop() {
  readMPU6050();
  
  accelX -= accelOffsetX;
  accelY -= accelOffsetY;
  
  float accelX_g = accelX / 16384.0;
  float accelY_g = accelY / 16384.0;
  
  smoothX[smoothIndex] = accelX_g;
  smoothY[smoothIndex] = accelY_g;
  smoothIndex = (smoothIndex + 1) % SMOOTH_SAMPLES;
  
  float avgX = 0, avgY = 0;
  for (int i = 0; i < SMOOTH_SAMPLES; i++) {
    avgX += smoothX[i];
    avgY += smoothY[i];
  }
  avgX /= SMOOTH_SAMPLES;
  avgY /= SMOOTH_SAMPLES;
  
  gravityX = alpha * gravityX + (1 - alpha) * avgX;
  gravityY = alpha * gravityY + (1 - alpha) * avgY;
  
  float dynX = avgX - gravityX;
  float dynY = avgY - gravityY;
  
  float totalG = sqrt(dynX * dynX + dynY * dynY);
  float angle = atan2(dynX, dynY);
  
  float angleDeg = angle * 180.0 / PI;
  if (angleDeg < 0) angleDeg += 360;
  int sector = (int)((angleDeg + 22.5) / 45.0) % 8;
  
  int fillLevel;
  if (totalG < 0.05) fillLevel = 0;
  else if (totalG < 0.5) fillLevel = 1;
  else if (totalG < 1.0) fillLevel = 2;
  else fillLevel = 3;
  
  float sectorCenter = sector * 45.0;
  float distanceFromCenter = abs(angleDeg - sectorCenter);
  bool nearBorder = (distanceFromCenter > BORDER_THRESHOLD);
  
  int sector2 = -1;
  int fillLevel2 = 0;
  
  if (nearBorder && fillLevel > 0) {
    if (angleDeg < sectorCenter) {
      sector2 = (sector - 1 + 8) % 8;
    } else {
      sector2 = (sector + 1) % 8;
    }
    fillLevel2 = fillLevel - 1;
    if (fillLevel2 <= 0) {
      sector2 = -1;
      fillLevel2 = 0;
    }
  }
  
  bool sectorChanged = (sector != lastSector || 
                        fillLevel != lastFillLevel ||
                        sector2 != lastSector2 ||
                        fillLevel2 != lastFillLevel2);
  
  if (sectorChanged) {
    if (lastSector >= 0 && lastFillLevel > 0) {
      clearSectorFast(lastSector, lastFillLevel);
    }
    if (lastSector2 >= 0 && lastFillLevel2 > 0) {
      clearSectorFast(lastSector2, lastFillLevel2);
    }
    
    if (fillLevel > 0) {
      drawSectorFast(sector, fillLevel);
    }
    if (sector2 >= 0 && fillLevel2 > 0) {
      drawSectorFast(sector2, fillLevel2);
    }
    
    redrawRingsOverSectors();
    
    lastSector = sector;
    lastFillLevel = fillLevel;
    lastSector2 = sector2;
    lastFillLevel2 = fillLevel2;
  }
  
  bool gValueChanged = (abs(totalG - lastDisplayedG) > 0.05);
  if (gValueChanged || lastDisplayedG < 0) {
    drawGValue(totalG);
    lastDisplayedG = totalG;
  }
  
  if (DEBUG_DOT && totalG > 0.05) {
    drawDebugDot(angle, totalG);
  }
  
  delay(20);
}

// ═══════════════════════════════════════════════════════════
// KALIBRACE A ČTENÍ
// ═══════════════════════════════════════════════════════════

void calibrate() {
  long sumX = 0, sumY = 0, sumZ = 0;
  const int samples = 100;
  
  for (int i = 0; i < samples; i++) {
    readMPU6050();
    sumX += accelX;
    sumY += accelY;
    sumZ += accelZ;
    delay(10);
  }
  
  accelOffsetX = sumX / samples;
  accelOffsetY = sumY / samples;
  accelOffsetZ = sumZ / samples - 16384;
}

void readMPU6050() {
  Wire.beginTransmission(MPU6050_ADDR);
  Wire.write(MPU6050_ACCEL_XOUT_H);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU6050_ADDR, 6, true);
  
  accelX = Wire.read() << 8 | Wire.read();
  accelY = Wire.read() << 8 | Wire.read();
  accelZ = Wire.read() << 8 | Wire.read();
}

// ═══════════════════════════════════════════════════════════
// LOOKUP TABLES
// ═══════════════════════════════════════════════════════════

void buildLookupTables() {
  for (int y = 0; y < 240; y++) {
    for (int x = 0; x < 240; x++) {
      pixelSector[y][x] = 255;
      pixelLayer[y][x] = 0;
      pixelIsRing[y][x] = false;
    }
  }
  
  for (int y = CENTER_Y - 120; y <= CENTER_Y + 120; y++) {
    for (int x = CENTER_X - 120; x <= CENTER_X + 120; x++) {
      
      if (x < 0 || x >= 240 || y < 0 || y >= 240) continue;
      
      int dx = x - CENTER_X;
      int dy = y - CENTER_Y;
      int distSq = dx*dx + dy*dy;
      float distance = sqrt(distSq);
      
      float angle = atan2(-dy, -dx) * 180.0 / PI;
      if (angle < 0) angle += 360;
      
      // Světle šedé kruhy s rovnými mezerami
      auto checkRingWithGap = [&](float ringRadius) -> bool {
        if (distance < ringRadius - RING_THICKNESS || distance > ringRadius) {
          return false;
        }
        
        bool inGap = false;
        
        for (int s = 0; s < 8; s++) {
          float borderAngle = (s * 45.0 + 22.5);
          if (borderAngle >= 360) borderAngle -= 360;
          
          float borderRad = borderAngle * PI / 180.0;
          float pixelRad = angle * PI / 180.0;
          
          float perpDistance = abs(distance * sin(pixelRad - borderRad));
          
          if (perpDistance < RING_GAP_WIDTH / 2.0) {
            inGap = true;
            break;
          }
        }
        
        return !inGap;
      };
      
      if (checkRingWithGap(RING1_RADIUS)) pixelIsRing[y][x] = true;
      if (checkRingWithGap(RING2_RADIUS)) pixelIsRing[y][x] = true;
      if (checkRingWithGap(RING3_RADIUS)) pixelIsRing[y][x] = true;
      
      // Segmenty s rovnými mezerami
      if (distSq < TEXT_RADIUS*TEXT_RADIUS) continue;
      if (distSq > LAYER3_MAX*LAYER3_MAX) continue;
      
      uint8_t layer = 0;
      if (distance >= LAYER1_MIN && distance <= LAYER1_MAX) layer = 1;
      else if (distance >= LAYER2_MIN && distance <= LAYER2_MAX) layer = 2;
      else if (distance >= LAYER3_MIN && distance <= LAYER3_MAX) layer = 3;
      
      if (layer == 0) continue;
      
      uint8_t sector = (int)((angle + 22.5) / 45.0) % 8;
      
      bool inGap = false;
      
      for (int s = 0; s < 8; s++) {
        float borderAngle = (s * 45.0 + 22.5);
        if (borderAngle >= 360) borderAngle -= 360;
        
        float borderRad = borderAngle * PI / 180.0;
        float pixelRad = angle * PI / 180.0;
        
        float perpDistance = abs(distance * sin(pixelRad - borderRad));
        
        if (perpDistance < SEGMENT_GAP_WIDTH / 2.0) {
          inGap = true;
          break;
        }
      }
      
      if (inGap) continue;
      
      pixelSector[y][x] = sector;
      pixelLayer[y][x] = layer;
    }
  }
}

// ═══════════════════════════════════════════════════════════
// VYKRESLOVÁNÍ
// ═══════════════════════════════════════════════════════════

void drawSectorFast(int sector, int fillLevel) {
  for (int y = CENTER_Y - 120; y <= CENTER_Y + 120; y++) {
    for (int x = CENTER_X - 120; x <= CENTER_X + 120; x++) {
      
      if (x < 0 || x >= 240 || y < 0 || y >= 240) continue;
      
      if (pixelSector[y][x] == sector) {
        uint8_t layer = pixelLayer[y][x];
        
        if (layer > 0 && layer <= fillLevel) {
          uint16_t color;
          if (layer == 1) color = COLOR_BLUE;
          else if (layer == 2) color = COLOR_WHITE;
          else color = COLOR_RED;
          
          gfx->drawPixel(x, y, color);
        }
      }
    }
  }
}

void clearSectorFast(int sector, int fillLevel) {
  for (int y = CENTER_Y - 120; y <= CENTER_Y + 120; y++) {
    for (int x = CENTER_X - 120; x <= CENTER_X + 120; x++) {
      
      if (x < 0 || x >= 240 || y < 0 || y >= 240) continue;
      
      if (pixelSector[y][x] == sector) {
        uint8_t layer = pixelLayer[y][x];
        
        if (layer > 0 && layer <= fillLevel) {
          gfx->drawPixel(x, y, BLACK);
        }
      }
    }
  }
}

void redrawRingsOverSectors() {
  for (int y = CENTER_Y - 120; y <= CENTER_Y + 120; y++) {
    for (int x = CENTER_X - 120; x <= CENTER_X + 120; x++) {
      
      if (x < 0 || x >= 240 || y < 0 || y >= 240) continue;
      
      if (pixelIsRing[y][x]) {
        gfx->drawPixel(x, y, LIGHT_GRAY);
      }
    }
  }
}

void drawStaticElements() {
  gfx->drawCircle(CENTER_X, CENTER_Y, TEXT_RADIUS, GRAY_CIRCLE);
  gfx->drawCircle(CENTER_X, CENTER_Y, TEXT_RADIUS - 1, GRAY_CIRCLE);
  
  redrawRingsOverSectors();
}

void drawGValue(float g) {
  gfx->fillCircle(CENTER_X, CENTER_Y, TEXT_RADIUS - 2, BLACK);
  
  int gTimes10 = (int)(g * 10.0);
  
  char buffer[10];
  sprintf(buffer, "%d", gTimes10);
  
  gfx->setFont(&FreeSansBold24pt7b);
  gfx->setTextColor(WHITE);
  
  int16_t x1, y1;
  uint16_t w, h;
  gfx->getTextBounds(buffer, 0, 0, &x1, &y1, &w, &h);
  
  int maxWidth = 40;
  int textX = CENTER_X - maxWidth / 2 + (maxWidth - w) / 2;
  int textY = CENTER_Y + h / 2 - 8;
  gfx->setCursor(textX, textY);
  gfx->print(buffer);
  
  gfx->setFont();
  gfx->setTextColor(GRAY_CIRCLE);
  gfx->setTextSize(1);
  
  const char* label = "x10";
  int labelW = strlen(label) * 6;
  int labelX = CENTER_X - labelW / 2;
  int labelY = CENTER_Y + 16;
  gfx->setCursor(labelX, labelY);
  gfx->print(label);
}

void drawDebugDot(float angle, float g) {
  float radius = constrain(g * 50, 0, 115);
  int x = CENTER_X - cos(angle) * radius;
  int y = CENTER_Y - sin(angle) * radius;
  
  gfx->fillCircle(x, y, 5, BLUE);
  gfx->drawCircle(x, y, 5, CYAN);
}
